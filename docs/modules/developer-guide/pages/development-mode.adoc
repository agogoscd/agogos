= Development Mode

This tutorial shows you how to run a simple component build on Agogos using Minikube.

== Objectives

* Install Agogos into a Minikube cluster
* Define a simple component to build
* Build the component

== Before you begin
This tutorial assumes you have already setup `minikube`, `kubectl`, `OpenJDK 17`
and `Hashicorp Vault`. See the following for installation instructions:

* link:https://minikube.sigs.k8s.io/docs/start/[minikube start]
* link:https://minikube.sigs.k8s.io/docs/drivers/kvm2/[Linux: kvm2 driver for minikube]
* link:https://minikube.sigs.k8s.io/docs/drivers/hyperkit/[macOS: hyperkit driver for minikube]
* link:https://kubernetes.io/docs/tasks/tools/install-kubectl-linux/[kubectl]
* link:https://openjdk.org/[OpenJDK]
* link:https://developer.hashicorp.com/vault/downloads/[Hashicorp Vault]

[TIP]
====
* The `minikube` guide for the kvm2 driver contains a useful
link:https://minikube.sigs.k8s.io/docs/drivers/kvm2/#troubleshooting[troubleshooting guide.]
* `Hashicorp Vault`: Please contact the 
link:https://mail.google.com/chat/u/0/#chat/space/AAAA2w955F8[Agogos development team]
to ensure that you have the necessary access to the vault.
====

== Untrusted Certificates
We need Minikube to trust the Red{nbsp}Hat root certificates as Agogos interacts
with many different internal services. The internal certificates are self-signed,
so they are considered
link:https://minikube.sigs.k8s.io/docs/handbook/untrusted_certs/[untrusted certificates].
Run:

[source,bash]
----
mkdir $HOME/.minikube/certs/
wget -O $HOME/.minikube/certs/RH-IT-Root-CA.crt https://certs.corp.redhat.com/certs/2015-IT-Root-CA.pem
wget -O $HOME/.minikube/certs/2022-IT-Root-CA.pem https://certs.corp.redhat.com/certs/2022-IT-Root-CA.pem
----

[TIP]
====
Your system may need to trust the Red{nbsp}Hat self-signed certificates as well. See the
link:https://source.redhat.com/groups/public/identity-access-management/it_iam_pki_rhcs_and_digicert/faqs_new_corporate_root_certificate_authority[FAQ on internal certificates]
for installation instructions.
====

== Create a Minikube Cluster

[source,bash]
----
minikube start --driver=kvm2 --cpus=4 --memory=6g --disk-size=30GB --kubernetes-version=1.26.1 --embed-certs
----

[IMPORTANT]
====
If your system is macOS, use `--driver=hyperkit`.
====

Minikube configures your [filename]`$HOME/.kube/config` to use the newly created
cluster. `kubectl` supports different contexts, see
link:https://kubernetes.io/docs/concepts/configuration/organize-cluster-access-kubeconfig/[organize cluster access]
for detailed information.

Use `kubectl config current-context` to see the context you are working in. It
should return `minikube`.

== Open Firewall Ports From Minikube To The Host
The Kubernetes cluster needs to contact Agogos' Webhooks for resource validation.
In development mode this means that Minikube needs to access some host ports. Here,
we provide information about how to achieve when using `firewalld`. Make
sure `firewalld` is running, then run:

[source,bash]
----
sudo firewall-cmd --permanent --zone=libvirt --add-port=8443/tcp  # This opens the port after restart
sudo firewall-cmd --zone=libvirt --add-port=8443/tcp  # This opens the port immediately
----

To open the port 8443 from the Minikube Virtual Machine to localhost.

== Installing Agogos in Development Mode
In the root of the repository, run:

[source,bash]
----
./mvnw clean package -D skipTests
----

This command compiles all the Agogos packages. To install the Agogos Operator, run:

[source,bash]
----
java -Dquarkus.profile=dev -Dagogos.cli-profile=admin -jar cli/target/quarkus-app/quarkus-run.jar adm install --profile dev
----

This command install Tekton, Knative Eventing and the Agogos CustomResourceDefinitions,
as well as the Agogos webhooks. It also creates a self-signed certificate
([filename]`webhooks.pem` and [filename]`webhooks.crt`) to encrypt the Agogos
webhooks endpoint.

Configure the namespace to use Agogos. Execute:

[source,bash]
----
java -Dquarkus.profile=dev -Dagogos.cli-profile=admin -jar cli/target/quarkus-app/quarkus-run.jar adm init --namespace tests
----

This command creates service accounts, rolebindings, configuration maps... Then
change the namespace the `kubectl` uses by default:

[source,bash]
----
kubectl config set-context --current --namespace tests
----

[WARNING]
====
The Agogos CLI uses the namespace configured in your current `kubectl` context.
====

== Forwarding the Knative Eventing Broker Ingress
Agogos sends events to the Knative Eventing service. In this tutorial, we run
Agogos locally, so the Knative Eventing service needs to be available at localhost.
Run:

[source,bash]
----
kubectl -n knative-eventing port-forward service/broker-ingress 8111:http
----

This command forwards the HTTP port of the service to the port `8111` on
localhost. It is a blocking command, so run it in a separate shell.

== Running Agogos
Agogos has different components. You need to keep them running in
separate shells (press 'q' to exit their processes):

[source,bash]
.Running the Operator
----
./mvnw quarkus:dev -pl operator -am
----

[source,bash]
.Running the Webhooks
----
./mvnw quarkus:dev -pl webhooks -am
----

[source,bash]
.Running the Interceptors
----
./mvnw quarkus:dev -pl interceptors -am
----

Quarkus runs a debug port by default. Since we are running three instances of
Quarkus, an error is printed:

[source,text]
----
[ERROR] Port 5005 in use, not starting in debug mode
----

If you want the Quarkus debugger for both processes, you need to change the debug
port. See the Quarkus documentation for detailed information.

[TIP]
====
You can start Agogos directly from Visual Studio Code, see the
xref:ide.adoc[IDE guide].
====

== Building Components
When you have Agogos up and running, run:

[source,bash]
----
# Setup vault environment variables
export VAULT_ADDR=https://vault.corp.redhat.com:8200
export VAULT_NAMESPACE=exd
export HV_TOKEN=$(vault login -method=oidc -field=token 2>/dev/null)

# Clone and run a python script to install a builder
git clone https://gitlab.cee.redhat.com/agogos/extensions-internal.git
cd extensions-internal
pipenv install
pipenv shell
python install/install.py builders/dummy/v1/ --hv-token=${HV_TOKEN}

----

[NOTES]
====
* If the process fails trying to create a fork process, set the
  following variable before running: 
  [command]`export OBJC_DISABLE_INITIALIZE_FORK_SAFETY=YES`.
* If you run into permission issues, ask the Agogos team to add you to the proper
  Rover team and refresh your token by logging into HashiCorp Vault again.
====

This command registers the Agogos dummy builder and the Tekton dummy
ClusterTask. Retrieve the builder using:

[source,bash]
----
kubectl get builders
# or
java -Dquarkus.profile=dev -jar cli/target/quarkus-app/quarkus-run.jar -v builders list
----

Next, write the following Components to a YAML file and apply them using 
[command]`kubectl apply -f your-file.yml`:

[source,yaml]
----
include::example$development-mode/components.yaml[]
----

And then run a build using the Agogos CLI:

[source,bash]
----
$ java -Dquarkus.profile=dev -jar cli/target/quarkus-app/quarkus-run.jar -v components list
NAME          STATUS    CREATED
dummy-1       Ready     YYYY-MM-DD HH:MM:SS
dummy-2       Ready     YYYY-MM-DD HH:MM:SS
dummy-3       Ready     YYYY-MM-DD HH:MM:SS

$ java -Dquarkus.profile=dev -jar cli/target/quarkus-app/quarkus-run.jar -v components build dummy-1
ðŸ’– About

Name:       dummy-1-cn2rj

ðŸŽ‰ Status

Status:     Running
Reason:     Build is running
Created:    YYYY-MM-DD HH:MM:SS
Started:    YYYY-MM-DD HH:MM:SS
Finished:   N/A
Duration:   0 minute(s)
----

After a while, `dummy-1` and its dependents should be finished:

[source,bash]
----
$ java -Dquarkus.profile=dev -jar cli/target/quarkus-app/quarkus-run.jar -v builds list
NAME                STATUS       CREATED
dummy-1-cn2rj       Finished     YYYY-MM-DD HH:MM:SS
dummy-2-z22dj       Finished     YYYY-MM-DD HH:MM:SS
dummy-3-mwv9q       Finished     YYYY-MM-DD HH:MM:SS
----


== Building Groups
Agogos supports Groups to build Components and triggers the builds of their
dependencies. Create a YAML file with the following content and apply it to your
namespace using [command]`kubectl apply -f your-group-file.yml`:

[source,yaml]
----
include::example$development-mode/components-and-group.yaml[]
----

Then build the Group `group-1` using the Agogos CLI:

[source,bash]
----
$ java -Dquarkus.profile=dev -jar cli/target/quarkus-app/quarkus-run.jar -v group execute group-1
ðŸ’– About

Name:       group-1-s95mg

Components: Name                            Status    Started              Completed            Duration
            dummy-1-a                       New       N/A                  N/A
            dummy-1-b                       New       N/A                  N/A

ðŸŽ‰ Status

Status:     Running
Reason:     N/A
Created:    YYYY-MM-DD HH:MM:SS
Started:    YYYY-MM-DD HH:MM:SS
Finished:   N/A
Duration:   0 minute(s)
----

After a while, the Group Components and their dependents should be finished:

[source,bash]
----
$ java -Dquarkus.profile=dev -jar cli/target/quarkus-app/quarkus-run.jar -v builds list
NAME                STATUS       CREATED
dummy-1-a-chb7x     Finished     YYYY-MM-DD HH:MM:SS
dummy-1-b-lfwvr     Finished     YYYY-MM-DD HH:MM:SS
dummy-2-g7zwz       Finished     YYYY-MM-DD HH:MM:SS
dummy-3-t89hc       Finished     YYYY-MM-DD HH:MM:SS
----
