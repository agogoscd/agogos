= Kubernetes SSL Certificate Tutorial
:cfssl-version: 1.5.0

== Requirements

In order to create SSL certificates we will use the
link:https://github.com/cloudflare/cfssl[CFSSL (Cloudflare's PKI and TLS toolkit)].

Please download and install all the required [filename]`cfssl` tools.

Below you can find helper commands to install
link:https://github.com/cloudflare/cfssl/releases/tag/v{cfssl-version}[version {cfssl-version}].

[source,bash,subs="attributes+"]
----
curl -L https://github.com/cloudflare/cfssl/releases/download/v{cfssl-version}/cfssl_{cfssl-version}_linux_amd64 \
     -o cfssl
chmod +x cfssl

curl -L https://github.com/cloudflare/cfssl/releases/download/v{cfssl-version}/cfssljson_{cfssl-version}_linux_amd64 \
     -o cfssljson
chmod +x cfssljson

curl -L https://github.com/cloudflare/cfssl/releases/download/v{cfssl-version}/cfssl-certinfo_{cfssl-version}_linux_amd64 \
     -o cfssl-certinfo
chmod +x cfssl-certinfo
----

== Certificate generation

Create a [filename]`csr.json` input file for CFSSL with the following content:

[source,json]
.csr.json
----
{
  "hosts": [
    "agogos-webhooks.default.svc.cluster.local",
    "agogos-webhooks.default.svc",
    "192.168.39.1" <1>
  ],
  "CN": "system:node:agogos-webhooks.default.svc",
  "key": {
    "algo": "rsa",
    "size": 4096
  },
  "names": [
    {
      "C": "US",
      "ST": "NC",
      "L": "Raleigh",
      "O": "system:nodes",
      "OU": "CP"
    }
  ]
}

----
<1> If you want to use this certificate outside of the cluster, make sure you
add the relevant IP addresses and/or DNS names.

[source,bash]
----
❯ cat csr.json | cfssl genkey - | cfssljson -bare server
2021/02/10 15:31:31 [INFO] generate received request
2021/02/10 15:31:31 [INFO] received CSR
2021/02/10 15:31:31 [INFO] generating key: rsa-4096
2021/02/10 15:31:32 [INFO] encoded CSR
----

This generates two files:

. `server.csr` which contains the CSR, and
. `server-key.pem` being a private key in PEM format.

To create a signing request in the cluster, please run this command:

[source,bash]
----
cat <<EOF | kubectl apply -f -
apiVersion: certificates.k8s.io/v1
kind: CertificateSigningRequest
metadata:
  name: agogos-webhooks.default
spec:
  request: $(cat server.csr | base64 | tr -d '\n')
  signerName: kubernetes.io/kubelet-serving
  usages:
  - digital signature
  - key encipherment
  - server auth
EOF
----

A new signing request
`certificatesigningrequest.certificates.k8s.io/agogos.default`
should be created. You can confirm it by running:

[source,bash]
----
❯ kubectl get csr
NAME                      AGE     SIGNERNAME                      REQUESTOR       CONDITION
agogos-webhooks.default   7s      kubernetes.io/kubelet-serving   minikube-user   Pending
----

Now, let's approve it:

[source,bash]
----
❯ kubectl certificate approve agogos-webhooks.default
certificatesigningrequest.certificates.k8s.io/agogos-webhooks.default approved
----

After this step is completed you should have the certificate issued and ready
to use:

[source,bash]
----
❯ kubectl get csr
NAME                      AGE   SIGNERNAME                      REQUESTOR       CONDITION
agogos-webhooks.default   13s   kubernetes.io/kubelet-serving   minikube-user   Approved,Issued
----

Now we can fetch the certificate:

[source,bash]
----
❯ kubectl get csr agogos-webhooks.default \
  -o jsonpath='{.status.certificate}' | base64 --decode > server.crt
----

The server certificate is now available in the [filename]`server.crt` file.
Together with the [filename]`server-key.pem` it can be used to server data
over SSL.
